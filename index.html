
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>3-D Lobby | no-server</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,Arial}#hud{position:fixed;top:10px;left:10px;color:#fff;background:#0006;padding:8px 12px;border-radius:6px;font-size:14px;pointer-events:none}#c{width:100%;height:100%;display:block}</style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="hud">Admin: <span id="role">connectingâ€¦</span> | WASD RF-mouse | Q-drop cube | E-change colour | X-delete</div>

  <!-- Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.min.js"></script>
  <!-- Gun.js for peer sync -->
  <script src="https://cdn.jsdelivr.net/npm/gun@0.2020.1240/gun.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun@0.2020.1240/sea.js"></script>
  <!-- WebRTC adapter -->
  <script src="https://cdn.jsdelivr.net/npm/webrtc-adapter@8.2.3/out/adapter.min.js"></script>

  <script>
  /* ---------- CONFIG ---------- */
  const ROOM_KEY = '3dlobby';          // shared namespace
  const RELAY    = 'https://gun-manhattan.herokuapp.com/gun'; // free public relay
  /* ---------- BOOT ---------- */
  const gun = Gun(RELAY);
  const canvas = document.getElementById('c');
  const hudRole = document.getElementById('role');
  let isAdmin = false;

  /* ---------- THREE SETUP ---------- */
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x101018);
  scene.fog = new THREE.Fog(0x101018, 15, 120);
  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 3, 8);
  const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(devicePixelRatio);
  const hemi = new THREE.HemisphereLight(0xccccff, 0x444488, 1.2);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(10, 20, 10);
  scene.add(dir);
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(200, 200),
    new THREE.MeshStandardMaterial({color: 0x222233})
  );
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  /* ---------- PLAYER MOVEMENT ---------- */
  const keys = {};
  onkeydown = onkeyup = e => keys[e.key.toLowerCase()] = e.type === 'keydown';
  let mx = 0, my = 0, phi = 0, theta = 0;
  onmousemove = e => {
    if (document.pointerLockElement !== canvas) return;
    phi   -= e.movementX * 0.002;
    theta -= e.movementY * 0.002;
    theta = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, theta));
  };
  canvas.onclick = () => canvas.requestPointerLock();

  /* ---------- SYNCED OBJECTS ---------- */
  const boxes = new Map();  // id -> Mesh
  const palette = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7, 0xa0e7e5];
  let colourIndex = 0;

  function spawnBox(id, colour, x, y, z) {
    if (boxes.has(id)) return;
    const geo = new THREE.BoxGeometry(1, 1, 1);
    const mat = new THREE.MeshStandardMaterial({color: colour});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    boxes.set(id, mesh);
  }
  function removeBox(id) {
    const m = boxes.get(id);
    if (m) { scene.remove(m); boxes.delete(id); }
  }

  /* ---------- GUN LOGIC ---------- */
  gun.get(ROOM_KEY).get('owner').once(v => {
    if (v === null) {
      // first tab becomes admin
      isAdmin = true;
      gun.get(ROOM_KEY).get('owner').put(gun.user()._.sea.pub || 'anon');
      hudRole.textContent = 'Admin (you)';
    } else {
      hudRole.textContent = 'Guest (read-only)';
    }
  });

  // listen for objects
  gun.get(ROOM_KEY).get('objs').map().on((data, key) => {
    if (!data) { removeBox(key); return; }
    spawnBox(key, data.c, data.x, data.y, data.z);
  });

  /* ---------- ADMIN ACTIONS ---------- */
  function dropBox() {
    if (!isAdmin) return;
    const pos = camera.position.clone();
    pos.add(new THREE.Vector3(0, -1.5, 0));
    const id = Date.now().toString(36);
    const colour = palette[colourIndex % palette.length];
    gun.get(ROOM_KEY).get('objs').get(id).put({x: pos.x, y: pos.y, z: pos.z, c: colour});
  }
  function changeColour() {
    if (!isAdmin) return;
    colourIndex++;
  }
  function deleteAhead() {
    if (!isAdmin) return;
    const ray = new THREE.Raycaster();
    ray.setFromCamera(new THREE.Vector2(0, 0), camera);
    const ints = ray.intersectObjects([...boxes.values()]);
    if (ints.length) {
      const id = [...boxes.entries()].find(([,m]) => m === ints[0].object)[0];
      gun.get(ROOM_KEY).get('objs').get(id).put(null);
    }
  }

  /* ---------- LOOP ---------- */
  const velocity = new THREE.Vector3();
  function update() {
    requestAnimationFrame(update);
    /* movement */
    const speed = 0.15;
    velocity.set(0, 0, 0);
    if (keys['w']) velocity.z -= 1;
    if (keys['s']) velocity.z += 1;
    if (keys['a']) velocity.x -= 1;
    if (keys['d']) velocity.x += 1;
    if (keys['r']) velocity.y += 1;
    if (keys['f']) velocity.y -= 1;
    velocity.normalize().multiplyScalar(speed);
    velocity.applyEuler(new THREE.Euler(0, phi, 0));
    camera.position.add(velocity);
    camera.rotation.set(theta, phi, 0, 'YXZ');
    /* admin actions */
    if (keys['q']) { dropBox(); keys['q'] = false; }
    if (keys['e']) { changeColour(); keys['e'] = false; }
    if (keys['x']) { deleteAhead(); keys['x'] = false; }
    renderer.render(scene, camera);
  }
  update();

  onresize = () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  };
  </script>
</body>
</html>
---snip---
